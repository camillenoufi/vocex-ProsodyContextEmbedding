# -*- coding: utf-8 -*-
"""contour_segment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14nrrr_epRUsoTvjp4TtQWwsMTC4ju5z3
"""



# to prateek:  this set of helper functions would be called for each f0 track in the set of 3000.
#ultimately it returns a list of 350-frame numpy arrays and a corresponding list of frame indices that each contour starts at

import os
import numpy as np
import math
from scipy.integrate import cumtrapz
import pandas as pd

# HELPER FUNCTIONS

def loadF0PitchTrack(filename): # this would be loading the .csv for crepe
    ext = os.path.splitext(filename)[1]
    if(ext=='.csv'):
      df = pd.read_csv(filename)
      pitch_track = df.frequency #you can also use df['column_name']
    elif(ext == '.npy' or ext == '.npz'):
      pitch_track = np.load(filename)
      if(ext=='.npz'):
          pitch_track = pitch_track['pitch']
    return pitch_track

# convert array of freqs into array of cents
# returns one list of ints
def freq2cents(freqs):
    cents = [ 1200*np.log2(f/55) for f in freqs]
    return cents

# calculate derivative of cents-based contours, cap at eighth of a tone (26 cent) change per pYin frame (11.6ms)
# returns one list of ints
def calcDerivative(c):
    UPPER = 45
    LOWER = -1*UPPER
    NAN_FILL = LOWER - 1

    dc = np.diff(c)

    #corrections
    idxPos = [i for i,x in enumerate(dc) if x >= UPPER]
    idxNeg = [i for i,x in enumerate(dc) if x <= LOWER]
    idxNan = [i for i,x in enumerate(dc) if math.isnan(x)]
    dc[idxPos] = UPPER
    dc[idxNeg] = LOWER
    dc[idxNan] = NAN_FILL

    return dc,UPPER,LOWER,NAN_FILL


# integrate derivatives of sliced pitch contours (in cents) with an initialization of 0
def integrateDerivative(dc):
    return cumtrapz(dc, initial=0)

# sliceFeatures()
# Functionality: slice deriv track into contour frames of size K_MAX:
# input: derivative track (100-cent grid, constrained within UPPER & LOWER BOUNDS) of audio file
# _____ dc: list[]
# _____ K_min: min number of frames in contour
# _____ K_max: max number of frames in contour
# _____ UPPER: Upper bound of allowed derivative value
# _____ LOWER: Lower bound of allowed derivative value
# _____ NAN_FILL: (LOWER - 1) Placeholder for silences. Also used to pad end of contours to K_MAX
# returns: slices ( list of zero-padded derivative contours, i.e. list(np.arrays) )
def createContourSlices(dc, c, UPPER, LOWER, NAN_FILL, K_min, K_MAX):
    #return lists
    slices_dc = []
    slices_c = []
    slices_starting_frame = []
    slices_nonzero_length = []

    global max_frame_size #for tracking/debugging
    global max_frame_count #for tracking/debugging

    # segment track into contour sections
    i = 0
    while ( i <  (len(dc) - K_min) ):
        frame_size = 0

        # while derivative is "in bounds" and contour is less than K_max frames
        while ( (i+frame_size) < (len(dc)-1) and dc[i+frame_size] < UPPER and dc[i+frame_size] > LOWER):
            frame_size += 1

        #only append contours greater than K_min frames
        if (frame_size >= K_min):

            if(frame_size > K_MAX): #added to truncate > 350
              frame_size = K_MAX

            # append derivative contour (zero-extended) to master derivative slice list
            dc_contour = np.array(dc[i:i+frame_size])
            slices_dc.append( np.pad(dc_contour, (0, K_MAX-dc_contour.shape[0]), 'constant', constant_values=0) )

            # append original pitch contour (variable length <= 350) to master cents slice list
            c0 = integrateDerivative( dc_contour )
            contour = c0 - np.median(c0)
            slices_c.append( np.pad(contour, (0, K_MAX-contour.shape[0]), 'constant', constant_values=0) ) #all contour slices will start at 0

            #append location and length info
            slices_starting_frame.append(i)
            slices_nonzero_length.append(frame_size)

            #for tracking/debugging:
            if(frame_size > K_MAX) :
                max_frame_size = frame_size
                max_frame_count += 1

        # move to beginning of next frame start
        i = i + frame_size + 1

    return slices_dc, slices_c, slices_starting_frame, slices_nonzero_length


# create threshold-segmented contour slices for a specific .npy file
def preprocessAndSlice(filename, K_min, K_max):
    pt = loadF0PitchTrack(filename)

    # convert to cents
    c = freq2cents(pt) #pitch track in cents

    # calc derivatives
    dc,UPPER,LOWER,NAN_FILL = calcDerivative(c) #derivative of pitch track in cents (constrained)

    # chop into pitch contour-length features
    # returns list of contour derivatives and originals from one track
    slices_dc, slices_c, slices_starting_frame, slices_nonzero_length = createContourSlices(dc, c, UPPER, LOWER, NAN_FILL, K_min, K_max)

    #RETURN 4 lists
    return slices_dc, slices_c, slices_starting_frame, slices_nonzero_length

#slices_dc is a list[np.arrays()] of the derivative contour, zeropadded up to 350
#slices_c is a list[np.arrays()] of the original contour (centered at 0 cents), zeropadded up to 350
#slices_starting_frame is a list[ints] of the starting frame of the contour within the whole pitch track file
#slices_nonzero_length is a list[ints] of the non-zero frame length of the contour
